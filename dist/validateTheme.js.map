{
  "version": 3,
  "sources": ["../mod.ts", "../validateTheme.ts"],
  "sourcesContent": ["type Maybe<T> = T | undefined;\n\n/**************\n * ANSI CODES *\n *************/\n\nexport const RESET_CODE: number = 0;\n\n// noinspection JSUnusedGlobalSymbols\nexport enum ForegroundSimpleCode {\n  FG_Black = 30,\n  FG_Red = 31,\n  FG_Green = 32,\n  FG_Yellow = 33,\n  FG_Blue = 34,\n  FG_Magenta = 35,\n  FG_Cyan = 36,\n  FG_White = 37,\n  FG_Bright_Black = 90,\n  FG_Bright_Red = 91,\n  FG_Bright_Green = 92,\n  FG_Bright_Yellow = 93,\n  FG_Bright_Blue = 94,\n  FG_Bright_Magenta = 95,\n  FG_Bright_Cyan = 96,\n  FG_Bright_White = 97,\n}\n\n// noinspection JSUnusedGlobalSymbols\nexport enum BackgroundSimpleCode {\n  BG_Black = 40,\n  BG_Red = 41,\n  BG_Green = 42,\n  BG_Yellow = 43,\n  BG_Blue = 44,\n  BG_Magenta = 45,\n  BG_Cyan = 46,\n  BG_White = 47,\n  BG_Bright_Black = 100,\n  BG_Bright_Red = 101,\n  BG_Bright_Green = 102,\n  BG_Bright_Yellow = 103,\n  BG_Bright_Blue = 104,\n  BG_Bright_Magenta = 105,\n  BG_Bright_Cyan = 106,\n  BG_Bright_White = 107,\n}\n\n// noinspection JSUnusedGlobalSymbols\nexport enum DecorationCode {\n  Bold = 1,\n  Dim = 2,\n  Italic = 3,\n  Underline = 4,\n  Blink_Slow = 5,\n  Blink_Fast = 6,\n  Reverse_Video = 7,\n  Conceal = 8,\n  Crossed_Out = 9,\n  Primary = 10,\n  Alternative_Font_1 = 11,\n  Alternative_Font_2 = 12,\n  Alternative_Font_3 = 13,\n  Alternative_Font_4 = 14,\n  Alternative_Font_5 = 15,\n  Alternative_Font_6 = 16,\n  Alternative_Font_7 = 17,\n  Alternative_Font_8 = 18,\n  Alternative_Font_9 = 19,\n  Fraktur = 20,\n  Double_Underline = 21,\n  Normal = 22,\n  Italic_And_Fraktur_Off = 23,\n  Underline_Off = 24,\n  Blink_Off = 25,\n  Proportional_Spacing = 26,\n  Reverse_And_Invert_Off = 27,\n  Reveal_And_Conceal_Off = 28,\n  Crossed_Off = 29\n}\n\nfunction checkRgbRange (code: number) {\n  if (code < 0 || code > 255) {\n    throw Error(`RGB codes should be between 0 & 255, got: ${code}`);\n  }\n  return code;\n}\n\nexport class RgbCode {\n  red: number;\n  green: number;\n  blue: number;\n\n  constructor (red: number, green: number, blue: number) {\n    this.red = checkRgbRange(red);\n    this.green = checkRgbRange(green);\n    this.blue = checkRgbRange(blue);\n  }\n}\n\nexport class ForegroundRgbCode extends RgbCode {\n  override toString () {\n    return `38;2;${this.red};${this.green};${this.blue}`;\n  }\n}\n\nexport class BackgroundRgbCode extends RgbCode {\n  override toString () {\n    return `48;2;${this.red};${this.green};${this.blue}`;\n  }\n}\n\nexport type ForegroundCode = ForegroundSimpleCode | ForegroundRgbCode;\nexport type BackgroundCode = BackgroundSimpleCode | BackgroundRgbCode;\n\nexport interface Style {\n  color?: ForegroundCode,\n  backgroundColor?: BackgroundCode,\n  decoration?: DecorationCode,\n}\n\nexport function styleToAnsiCode ({ color, backgroundColor, decoration }: Style, shouldResetFirst: boolean = false): string {\n  const codes = [\n    ...(shouldResetFirst ? [ RESET_CODE ] : []),\n    color,\n    backgroundColor,\n    decoration,\n  ].filter((code) => (typeof code === 'number' || typeof code === 'object'));\n  return codes.length === 0 ? '' : `\\x1b[${codes.join(';')}m`;\n}\n\n/*******************\n * APPLYING STYLES *\n ******************/\n\nexport enum StyleMode { STYLE, NO_STYLE}\n\ninterface StylesToApply {\n  global?: Style,\n  edges?: Maybe<Style>[],\n  nodes?: Maybe<Style>[],\n}\n\ntype GlobalStyler = (style: Style, styleMode?: StyleMode) => string;\n\ntype Styler = (stylesToApply: StylesToApply, styleMode?: StyleMode) => string;\n\ninterface Fragment {\n  string: string,\n  shouldResetFirst: boolean,\n  style: Maybe<Style>,\n}\n\ninterface Accumulator {\n  currentStyle: Style,\n  fragments: Fragment[],\n}\n\nfunction areStylesEqual (style1: Style, style2: Style): boolean {\n  return style1.color === style2.color\n    && style1.backgroundColor === style2.backgroundColor\n    && style1.decoration === style2.decoration;\n}\n\nfunction computeNextFragment (string: string, lastStyle: Style, styleToApply: Maybe<Style>): Fragment {\n  if (!styleToApply || areStylesEqual(styleToApply, lastStyle)) { return { string, shouldResetFirst: false, style: undefined }; }\n\n  const shouldRemoveOldColor = !!lastStyle.color && !styleToApply.color;\n  const shouldRemoveOldBackgroundColor = !!lastStyle.backgroundColor && !styleToApply.backgroundColor;\n  const shouldRemoveOldDecoration = !!lastStyle.decoration && styleToApply.decoration !== lastStyle.decoration;\n  const shouldResetFirst = shouldRemoveOldColor || shouldRemoveOldBackgroundColor || shouldRemoveOldDecoration;\n\n  return { // Colors are reset if unset\n    string,\n    shouldResetFirst,\n    style: {\n      color: shouldResetFirst || styleToApply.color !== lastStyle.color ? styleToApply.color : undefined,\n      backgroundColor: shouldResetFirst || styleToApply.backgroundColor !== lastStyle.backgroundColor ? styleToApply.backgroundColor : undefined,\n      decoration: shouldResetFirst || styleToApply.decoration !== lastStyle.decoration ? styleToApply.decoration : undefined,\n    },\n  };\n}\n\nfunction computeNextCode<T> (lastCode: Maybe<T>, newCode: Maybe<T>, hasReset: boolean): Maybe<T> {\n  if (newCode) { return newCode; }\n  return hasReset || !lastCode ? undefined : lastCode;\n}\n\nfunction printFragmentStyle (fragment: Fragment) {\n  return fragment.style ? styleToAnsiCode(fragment.style, fragment.shouldResetFirst) : '';\n}\n\nfunction getString (index: number, edges: string[], nodes: any[]): string {\n  const isEven = index % 2 === 0;\n  const halfIndex = ~~(index / 2);\n  return String(\n    isEven ? edges[ halfIndex ] : nodes[ halfIndex ],\n  );\n}\n\nfunction getSpecificStyle (index: number, styles: StylesToApply): Maybe<Style> {\n  const isEven = index % 2 === 0;\n  const halfIndex = ~~(index / 2);\n  return isEven ? styles?.edges?.[ halfIndex ] : styles?.nodes?.[ halfIndex ];\n}\n\nexport function stoyleString (input: string, style: Style, styleMode: StyleMode = StyleMode.STYLE): string {\n  return styleMode === StyleMode.NO_STYLE\n    ? input\n    : styleToAnsiCode(style) + input + styleToAnsiCode({}, true);\n}\n\nexport function stoyleGlobal (edgesAsTemplateStringArray: TemplateStringsArray, ...nodes: any[]): GlobalStyler {\n  const edges = [ ...edgesAsTemplateStringArray ];\n  return (style: Style, styleMode: StyleMode = StyleMode.STYLE) => {\n    const wholeString = new Array(edges.length + nodes.length)\n      .fill(null)\n      .map((whatever, index) => getString(index, edges, nodes))\n      .join('');\n    return stoyleString(wholeString, style, styleMode);\n  };\n}\n\nexport function stoyle (edgesAsTemplateStringArray: TemplateStringsArray, ...nodes: any[]): Styler {\n  const edges = [ ...edgesAsTemplateStringArray ];\n  return (styles: StylesToApply, styleMode: StyleMode = StyleMode.STYLE) => {\n    if (styles.edges && edges.length !== styles.edges?.length) {\n      throw Error(`I found ${edges.length} edge(s), but ${styles.edges?.length} edge style(s)!`);\n    }\n\n    if (styles.nodes && nodes.length !== styles.nodes?.length) {\n      throw Error(`I found ${nodes.length} node(s), but ${styles.nodes?.length} node style(s)!`);\n    }\n\n    const globalStyle = styles?.global ?? {}; // Defaults to no style\n    const accumulator: Accumulator = new Array(edges.length + nodes.length)\n      .fill(null)\n      .reduce(\n        (seed: Accumulator, whatever, index) => {\n          const string = getString(index, edges, nodes);\n\n          if (!string) { return seed; } // Nothing to write for empty strings\n\n          const specificStyle = getSpecificStyle(index, styles);\n          const styleToApply = specificStyle ?? globalStyle; // Specific styles supersede global style\n          const fragment: Fragment = styleMode === StyleMode.NO_STYLE\n            ? { string, shouldResetFirst: false, style: {} }\n            : computeNextFragment(string, seed.currentStyle, styleToApply);\n\n          seed.fragments.push(fragment);\n          seed.currentStyle = {\n            color: computeNextCode(seed.currentStyle.color, fragment?.style?.color, fragment.shouldResetFirst),\n            backgroundColor: computeNextCode(seed.currentStyle.backgroundColor, fragment?.style?.backgroundColor, fragment.shouldResetFirst),\n            decoration: computeNextCode(seed.currentStyle.decoration, fragment?.style?.decoration, fragment.shouldResetFirst),\n          };\n          return seed;\n        },\n        {\n          currentStyle: {},\n          fragments: [],\n        } as Accumulator,\n      );\n\n    const { fragments, currentStyle: lastStyle } = accumulator;\n\n    const shouldCleanup = !!lastStyle.color\n      || !!lastStyle.backgroundColor\n      || !!lastStyle.decoration;\n\n    const allFragments = shouldCleanup\n      ? fragments.concat({ string: '', shouldResetFirst: true, style: {} })\n      : fragments;\n\n    return allFragments\n      .map((fragment: Fragment) => printFragmentStyle(fragment) + fragment.string)\n      .join('');\n  };\n}\n", "// @ts-ignore: Ignore TS2691\nimport { BackgroundSimpleCode, ForegroundSimpleCode, DecorationCode } from './mod.ts';\n\nfunction checkCodeProperty (code: Record<string, any>, propertyName: string): boolean {\n  return !!code[ propertyName ] && typeof code[ propertyName ] === 'number';\n}\n\nfunction checkValidCodeOrRgb (color: any, enumValues: any[]): boolean {\n  return checkValidCode(color, enumValues)\n    || (color.red && color.green && color.blue);\n}\n\nfunction checkValidCode (color: any, enumValues: any[]): boolean {\n  return enumValues.includes(color);\n}\n\nfunction recursiveValidateTheme (referenceTheme: Record<string, any>, theme: Record<string, any>, location: string[], errors: string[]): string[] {\n  Object.entries(referenceTheme)\n    .forEach(([ key, referenceCode ]) => {\n      if (!referenceCode) { return; }\n      if (typeof referenceCode !== 'object') { return; }\n\n      const themeCode = theme[ key ];\n      const childLocation = [ ...location, key ];\n      if (!checkCodeProperty(referenceCode, 'color')\n        && !checkCodeProperty(referenceCode, 'backgroundColor')\n        && !checkCodeProperty(referenceCode, 'decoration')) {\n        if (!themeCode || typeof themeCode !== 'object') {\n          errors.push(`The theme should contain an object at ${JSON.stringify(childLocation)}`);\n          return;\n        }\n\n        recursiveValidateTheme(referenceCode, themeCode, childLocation, errors);\n        return;\n      }\n\n      if (!themeCode || typeof themeCode !== 'object') {\n        errors.push(`The theme should contain a style at ${JSON.stringify(childLocation)}`);\n        return;\n      }\n\n      const themeColor = themeCode.color;\n      if (themeColor && !checkValidCodeOrRgb(themeColor, Object.values(ForegroundSimpleCode))) {\n        errors.push(`The theme color is invalid at ${JSON.stringify(childLocation)}. It should be a ForegroundSimpleCode or ForegroundRgbCode`);\n      }\n\n      const themeBackgroundColor = themeCode.backgroundColor;\n      if (themeBackgroundColor && !checkValidCodeOrRgb(themeBackgroundColor, Object.values(BackgroundSimpleCode))) {\n        errors.push(`The theme backgroundColor is invalid at ${JSON.stringify(childLocation)}. It should be a BackgroundSimpleCode or BackgroundRgbCode`);\n      }\n\n      const themeDecoration = themeCode.decoration;\n      if (themeDecoration && !checkValidCode(themeDecoration, Object.values(DecorationCode))) {\n        errors.push(`The theme decoration is invalid at ${JSON.stringify(childLocation)}. It should be a DecorationCode`);\n      }\n    });\n\n  return errors;\n}\n\nexport function validateTheme (referenceTheme: Record<string, any>, theme: Record<string, any>): Record<string, any> {\n  const errors = recursiveValidateTheme(referenceTheme, theme, [], []);\n\n  if (errors.length) {\n    throw new Error(`[Theme errors]\\n* ${errors.join('\\n* ')}`);\n  }\n\n  return theme;\n}\n"],
  "mappings": "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",
  "names": ["ForegroundSimpleCode", "BackgroundSimpleCode", "DecorationCode", "checkCodeProperty", "code", "propertyName", "checkValidCodeOrRgb", "color", "enumValues", "checkValidCode", "recursiveValidateTheme", "referenceTheme", "theme", "location", "errors", "key", "referenceCode", "themeCode", "childLocation", "themeColor", "ForegroundSimpleCode", "themeBackgroundColor", "BackgroundSimpleCode", "themeDecoration", "DecorationCode", "validateTheme"]
}

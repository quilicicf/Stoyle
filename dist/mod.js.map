{
  "version": 3,
  "sources": ["../mod.ts"],
  "sourcesContent": ["type Maybe<T> = T | undefined;\n\n/**************\n * ANSI CODES *\n *************/\n\nexport const RESET_CODE: number = 0;\n\n// noinspection JSUnusedGlobalSymbols\nexport enum ForegroundSimpleCode {\n  FG_Black = 30,\n  FG_Red = 31,\n  FG_Green = 32,\n  FG_Yellow = 33,\n  FG_Blue = 34,\n  FG_Magenta = 35,\n  FG_Cyan = 36,\n  FG_White = 37,\n  FG_Bright_Black = 90,\n  FG_Bright_Red = 91,\n  FG_Bright_Green = 92,\n  FG_Bright_Yellow = 93,\n  FG_Bright_Blue = 94,\n  FG_Bright_Magenta = 95,\n  FG_Bright_Cyan = 96,\n  FG_Bright_White = 97,\n}\n\n// noinspection JSUnusedGlobalSymbols\nexport enum BackgroundSimpleCode {\n  BG_Black = 40,\n  BG_Red = 41,\n  BG_Green = 42,\n  BG_Yellow = 43,\n  BG_Blue = 44,\n  BG_Magenta = 45,\n  BG_Cyan = 46,\n  BG_White = 47,\n  BG_Bright_Black = 100,\n  BG_Bright_Red = 101,\n  BG_Bright_Green = 102,\n  BG_Bright_Yellow = 103,\n  BG_Bright_Blue = 104,\n  BG_Bright_Magenta = 105,\n  BG_Bright_Cyan = 106,\n  BG_Bright_White = 107,\n}\n\n// noinspection JSUnusedGlobalSymbols\nexport enum DecorationCode {\n  Bold = 1,\n  Dim = 2,\n  Italic = 3,\n  Underline = 4,\n  Blink_Slow = 5,\n  Blink_Fast = 6,\n  Reverse_Video = 7,\n  Conceal = 8,\n  Crossed_Out = 9,\n  Primary = 10,\n  Alternative_Font_1 = 11,\n  Alternative_Font_2 = 12,\n  Alternative_Font_3 = 13,\n  Alternative_Font_4 = 14,\n  Alternative_Font_5 = 15,\n  Alternative_Font_6 = 16,\n  Alternative_Font_7 = 17,\n  Alternative_Font_8 = 18,\n  Alternative_Font_9 = 19,\n  Fraktur = 20,\n  Double_Underline = 21,\n  Normal = 22,\n  Italic_And_Fraktur_Off = 23,\n  Underline_Off = 24,\n  Blink_Off = 25,\n  Proportional_Spacing = 26,\n  Reverse_And_Invert_Off = 27,\n  Reveal_And_Conceal_Off = 28,\n  Crossed_Off = 29\n}\n\nfunction checkRgbRange (code: number) {\n  if (code < 0 || code > 255) {\n    throw Error(`RGB codes should be between 0 & 255, got: ${code}`);\n  }\n  return code;\n}\n\nexport class RgbCode {\n  red: number;\n  green: number;\n  blue: number;\n\n  constructor (red: number, green: number, blue: number) {\n    this.red = checkRgbRange(red);\n    this.green = checkRgbRange(green);\n    this.blue = checkRgbRange(blue);\n  }\n}\n\nexport class ForegroundRgbCode extends RgbCode {\n  override toString () {\n    return `38;2;${this.red};${this.green};${this.blue}`;\n  }\n}\n\nexport class BackgroundRgbCode extends RgbCode {\n  override toString () {\n    return `48;2;${this.red};${this.green};${this.blue}`;\n  }\n}\n\nexport type ForegroundCode = ForegroundSimpleCode | ForegroundRgbCode;\nexport type BackgroundCode = BackgroundSimpleCode | BackgroundRgbCode;\n\nexport interface Style {\n  color?: ForegroundCode,\n  backgroundColor?: BackgroundCode,\n  decoration?: DecorationCode,\n}\n\nexport function styleToAnsiCode ({ color, backgroundColor, decoration }: Style, shouldResetFirst: boolean = false): string {\n  const codes = [\n    ...(shouldResetFirst ? [ RESET_CODE ] : []),\n    color,\n    backgroundColor,\n    decoration,\n  ].filter((code) => (typeof code === 'number' || typeof code === 'object'));\n  return codes.length === 0 ? '' : `\\x1b[${codes.join(';')}m`;\n}\n\n/*******************\n * APPLYING STYLES *\n ******************/\n\nexport enum StyleMode { STYLE, NO_STYLE}\n\ninterface StylesToApply {\n  global?: Style,\n  edges?: Maybe<Style>[],\n  nodes?: Maybe<Style>[],\n}\n\ntype GlobalStyler = (style: Style, styleMode?: StyleMode) => string;\n\ntype Styler = (stylesToApply: StylesToApply, styleMode?: StyleMode) => string;\n\ninterface Fragment {\n  string: string,\n  shouldResetFirst: boolean,\n  style: Maybe<Style>,\n}\n\ninterface Accumulator {\n  currentStyle: Style,\n  fragments: Fragment[],\n}\n\nfunction areStylesEqual (style1: Style, style2: Style): boolean {\n  return style1.color === style2.color\n    && style1.backgroundColor === style2.backgroundColor\n    && style1.decoration === style2.decoration;\n}\n\nfunction computeNextFragment (string: string, lastStyle: Style, styleToApply: Maybe<Style>): Fragment {\n  if (!styleToApply || areStylesEqual(styleToApply, lastStyle)) { return { string, shouldResetFirst: false, style: undefined }; }\n\n  const shouldRemoveOldColor = !!lastStyle.color && !styleToApply.color;\n  const shouldRemoveOldBackgroundColor = !!lastStyle.backgroundColor && !styleToApply.backgroundColor;\n  const shouldRemoveOldDecoration = !!lastStyle.decoration && styleToApply.decoration !== lastStyle.decoration;\n  const shouldResetFirst = shouldRemoveOldColor || shouldRemoveOldBackgroundColor || shouldRemoveOldDecoration;\n\n  return { // Colors are reset if unset\n    string,\n    shouldResetFirst,\n    style: {\n      color: shouldResetFirst || styleToApply.color !== lastStyle.color ? styleToApply.color : undefined,\n      backgroundColor: shouldResetFirst || styleToApply.backgroundColor !== lastStyle.backgroundColor ? styleToApply.backgroundColor : undefined,\n      decoration: shouldResetFirst || styleToApply.decoration !== lastStyle.decoration ? styleToApply.decoration : undefined,\n    },\n  };\n}\n\nfunction computeNextCode<T> (lastCode: Maybe<T>, newCode: Maybe<T>, hasReset: boolean): Maybe<T> {\n  if (newCode) { return newCode; }\n  return hasReset || !lastCode ? undefined : lastCode;\n}\n\nfunction printFragmentStyle (fragment: Fragment) {\n  return fragment.style ? styleToAnsiCode(fragment.style, fragment.shouldResetFirst) : '';\n}\n\nfunction getString (index: number, edges: string[], nodes: any[]): string {\n  const isEven = index % 2 === 0;\n  const halfIndex = ~~(index / 2);\n  return String(\n    isEven ? edges[ halfIndex ] : nodes[ halfIndex ],\n  );\n}\n\nfunction getSpecificStyle (index: number, styles: StylesToApply): Maybe<Style> {\n  const isEven = index % 2 === 0;\n  const halfIndex = ~~(index / 2);\n  return isEven ? styles?.edges?.[ halfIndex ] : styles?.nodes?.[ halfIndex ];\n}\n\nexport function stoyleString (input: string, style: Style, styleMode: StyleMode = StyleMode.STYLE): string {\n  return styleMode === StyleMode.NO_STYLE\n    ? input\n    : styleToAnsiCode(style) + input + styleToAnsiCode({}, true);\n}\n\nexport function stoyleGlobal (edgesAsTemplateStringArray: TemplateStringsArray, ...nodes: any[]): GlobalStyler {\n  const edges = [ ...edgesAsTemplateStringArray ];\n  return (style: Style, styleMode: StyleMode = StyleMode.STYLE) => {\n    const wholeString = new Array(edges.length + nodes.length)\n      .fill(null)\n      .map((whatever, index) => getString(index, edges, nodes))\n      .join('');\n    return stoyleString(wholeString, style, styleMode);\n  };\n}\n\nexport function stoyle (edgesAsTemplateStringArray: TemplateStringsArray, ...nodes: any[]): Styler {\n  const edges = [ ...edgesAsTemplateStringArray ];\n  return (styles: StylesToApply, styleMode: StyleMode = StyleMode.STYLE) => {\n    if (styles.edges && edges.length !== styles.edges?.length) {\n      throw Error(`I found ${edges.length} edge(s), but ${styles.edges?.length} edge style(s)!`);\n    }\n\n    if (styles.nodes && nodes.length !== styles.nodes?.length) {\n      throw Error(`I found ${nodes.length} node(s), but ${styles.nodes?.length} node style(s)!`);\n    }\n\n    const globalStyle = styles?.global ?? {}; // Defaults to no style\n    const accumulator: Accumulator = new Array(edges.length + nodes.length)\n      .fill(null)\n      .reduce(\n        (seed: Accumulator, whatever, index) => {\n          const string = getString(index, edges, nodes);\n\n          if (!string) { return seed; } // Nothing to write for empty strings\n\n          const specificStyle = getSpecificStyle(index, styles);\n          const styleToApply = specificStyle ?? globalStyle; // Specific styles supersede global style\n          const fragment: Fragment = styleMode === StyleMode.NO_STYLE\n            ? { string, shouldResetFirst: false, style: {} }\n            : computeNextFragment(string, seed.currentStyle, styleToApply);\n\n          seed.fragments.push(fragment);\n          seed.currentStyle = {\n            color: computeNextCode(seed.currentStyle.color, fragment?.style?.color, fragment.shouldResetFirst),\n            backgroundColor: computeNextCode(seed.currentStyle.backgroundColor, fragment?.style?.backgroundColor, fragment.shouldResetFirst),\n            decoration: computeNextCode(seed.currentStyle.decoration, fragment?.style?.decoration, fragment.shouldResetFirst),\n          };\n          return seed;\n        },\n        {\n          currentStyle: {},\n          fragments: [],\n        } as Accumulator,\n      );\n\n    const { fragments, currentStyle: lastStyle } = accumulator;\n\n    const shouldCleanup = !!lastStyle.color\n      || !!lastStyle.backgroundColor\n      || !!lastStyle.decoration;\n\n    const allFragments = shouldCleanup\n      ? fragments.concat({ string: '', shouldResetFirst: true, style: {} })\n      : fragments;\n\n    return allFragments\n      .map((fragment: Fragment) => printFragmentStyle(fragment) + fragment.string)\n      .join('');\n  };\n}\n"],
  "mappings": "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",
  "names": ["RESET_CODE", "ForegroundSimpleCode", "BackgroundSimpleCode", "DecorationCode", "checkRgbRange", "code", "RgbCode", "red", "green", "blue", "ForegroundRgbCode", "BackgroundRgbCode", "styleToAnsiCode", "color", "backgroundColor", "decoration", "shouldResetFirst", "codes", "StyleMode", "areStylesEqual", "style1", "style2", "computeNextFragment", "string", "lastStyle", "styleToApply", "shouldRemoveOldColor", "shouldRemoveOldBackgroundColor", "shouldRemoveOldDecoration", "computeNextCode", "lastCode", "newCode", "hasReset", "printFragmentStyle", "fragment", "getString", "index", "edges", "nodes", "isEven", "halfIndex", "getSpecificStyle", "styles", "stoyleString", "input", "style", "styleMode", "stoyleGlobal", "edgesAsTemplateStringArray", "wholeString", "whatever", "stoyle", "globalStyle", "accumulator", "seed", "fragments"]
}
